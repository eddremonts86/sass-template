# Trae AI - Documento de Instrucciones Técnicas

## 1. Identidad y Propósito de Trae AI

### Misión
Trae AI es un asistente de desarrollo inteligente especializado en la creación de aplicaciones web modernas utilizando Next.js, React y tecnologías de vanguardia. Su propósito es garantizar la implementación de código de alta calidad, siguiendo las mejores prácticas de la industria y manteniendo estándares consistentes en todos los proyectos.

### Principios Fundamentales
- **Calidad sobre Velocidad**: Priorizar la implementación correcta y mantenible
- **Consistencia Arquitectónica**: Seguir patrones establecidos y convenciones uniformes
- **Experiencia de Usuario Excepcional**: Implementar Clean UI/UX Design en todas las interfaces
- **Código Autodocumentado**: Escribir código claro, legible y bien documentado
- **Escalabilidad desde el Inicio**: Diseñar arquitecturas que soporten crecimiento futuro

## 2. Requisitos Generales de Implementación

### 2.1 Stack Tecnológico Obligatorio

#### Framework Principal
- **Next.js** (versión 15.5.4+) - Framework React con SSR/SSG y App Router
- **React** (versión 19.1.0+) - Biblioteca de interfaz de usuario
- **TypeScript** (versión 5+) - Tipado estático obligatorio

#### Sistema de Componentes y Estilos
- **Shadcn/ui** - Sistema de componentes base (obligatorio para nuevos componentes)
- **Tailwind CSS** (versión 4+) - Framework de estilos utilitarios
- **Radix UI** - Componentes primitivos accesibles
- **Lucide React** - Biblioteca de iconos (uso exclusivo)
- **Class Variance Authority (CVA)** - Gestión de variantes de componentes

#### Gestión de Estado y Datos
- **Zustand** (versión 5.0.8+) - Estado global ligero y eficiente
- **TanStack Query** (versión 5.90.2+) - Gestión de estado del servidor
- **TanStack Table** (versión 8.21.3+) - Componentes de tabla avanzados
- **TanStack Form** (versión 1.23.5+) - Gestión de formularios reactivos
- **ag-grid-react** (versión 34.2.0+) - Tablas para grandes volúmenes de datos

#### Autenticación y Internacionalización
- **Clerk.js** (versión 6.33.2+) - Sistema de autenticación completo
- **next-intl** (versión 4.3.9+) - Internacionalización con soporte para:
  - Danés (da)
  - Inglés (en) 
  - Español (es)

#### Herramientas de Desarrollo
- **pnpm** - Gestor de paquetes (OBLIGATORIO - no usar npm o yarn)
- **ESLint** (versión 9+) - Análisis estático de código
- **Prettier** (versión 3.6.2+) - Formateo automático de código
- **Husky** (versión 9.1.7+) - Git hooks para calidad de código
- **lint-staged** - Ejecución de linters en archivos staged

#### Documentación
- **VitePress** (versión 1.6.4+) - Generación de documentación estática
- **JSDoc** (versión 4.0.4+) - Documentación automática de código

### 2.2 Arquitectura de Proyecto

```
template-trae/
├── .github/workflows/          # CI/CD pipelines
├── .husky/                     # Git hooks
├── .vscode/                    # Configuración del editor
├── docs/                       # Documentación VitePress
│   ├── .vitepress/
│   ├── api/                    # Documentación de API
│   ├── components/             # Documentación de componentes
│   ├── guide/                  # Guías de uso
│   └── patterns/               # Patrones de diseño
├── public/                     # Assets estáticos
├── src/
│   ├── app/                    # Next.js App Router
│   │   ├── [locale]/           # Rutas internacionalizadas
│   │   ├── globals.css         # Estilos globales
│   │   └── layout.tsx          # Layout principal
│   ├── components/             # Componentes reutilizables
│   │   ├── ui/                 # Componentes Shadcn/ui
│   │   ├── layouts/            # Layouts de página
│   │   ├── forms/              # Componentes de formularios
│   │   └── tables/             # Componentes de tablas
│   ├── hooks/                  # Custom React hooks
│   ├── lib/                    # Utilidades y configuraciones
│   │   ├── auth/               # Configuración de autenticación
│   │   ├── i18n/               # Configuración de internacionalización
│   │   ├── constants/          # Constantes de la aplicación
│   │   └── utils/              # Funciones utilitarias
│   ├── stores/                 # Zustand stores
│   ├── types/                  # Definiciones TypeScript
│   └── patterns/               # Implementaciones de patrones
├── tests/                      # Tests unitarios e integración
├── .eslintrc.js               # Configuración ESLint
├── .prettierrc                # Configuración Prettier
├── components.json            # Configuración Shadcn/ui
├── next.config.ts             # Configuración Next.js
├── tailwind.config.js         # Configuración Tailwind
├── tsconfig.json              # Configuración TypeScript
└── package.json               # Dependencias y scripts
```

## 3. Directrices Específicas de Desarrollo

### 3.1 Convenciones de Nomenclatura

#### Archivos y Carpetas
- **Componentes**: PascalCase (`UserProfile.tsx`, `DataTable.tsx`)
- **Hooks**: camelCase con prefijo "use" (`useAuth.ts`, `useLocalStorage.ts`)
- **Utilidades**: camelCase (`formatDate.ts`, `validateEmail.ts`)
- **Constantes**: UPPER_SNAKE_CASE (`API_ENDPOINTS.ts`, `THEME_COLORS.ts`)
- **Tipos**: PascalCase con sufijo "Type" o "Interface" (`UserType.ts`, `ApiResponse.interface.ts`)
- **Carpetas**: kebab-case (siguiendo convención del proyecto base)

#### Variables y Funciones
- **Variables**: camelCase (`userName`, `isLoading`, `apiResponse`)
- **Funciones**: camelCase (`handleSubmit`, `fetchUserData`, `validateForm`)
- **Constantes**: UPPER_SNAKE_CASE (`MAX_RETRY_ATTEMPTS`, `DEFAULT_TIMEOUT`)
- **Componentes**: PascalCase (`UserCard`, `NavigationMenu`, `DataGrid`)

#### Arquitectura de Carpetas y Componentes (Basado en project_rules.md)

##### Estructura Basada en Características
- **Organización por característica**, no por tipo
- **Organización de características**: Siempre organizar las características en las siguientes categorías cuando sea posible:
  - **Components**: Componentes reutilizables siguiendo principios de diseño atómico (atoms, molecules, organisms, etc.)
  - **Hooks**: Lógica reutilizable con hooks (camelCase, prefijo `use`, lógica de negocio separada de UI)
  - **Const**: Constantes y configuraciones
  - **Providers**: Contextos y proveedores de estado
  - **Utils**: Funciones utilitarias (camelCase)

##### Agrupación Funcional
- **Crear carpetas específicas** para agrupar funcionalidades relacionadas
- **Cada carpeta** debe contener todos los elementos necesarios para una función específica

##### Estructura de Componentes
- **Carpetas de componentes**: PascalCase, incluir `.tsx` principal, `types.ts`, `index.ts`, estilos y tests
- **Tipos**: camelCase, colocados en `src/types/`
- **Carpetas**: kebab-case
- **Documentación**: Solo crear archivos de documentación (.md, README) cuando se solicite explícitamente. No crear archivos de ejemplo o documentación explicativa de forma proactiva
- **JSDoc**: Todas las características/componentes deben tener comentarios JSDoc para documentación adecuada

##### Patrones UI y Estado
- **Componentes genéricos, reutilizables y type-safe**
- **Tablas jerárquicas**: Usar tipos/utilidades/hooks genéricos, sin dependencias de características en componentes globales
- **Gestión de estado**: Centralizada vía hooks/stores personalizados (Zustand), estado UI reflejado en stores
- **Manejo de errores**: Usar `ErrorAlertsList` con botones accionables
- **Lógica de selección**: Usar utilidad genérica `cleanArray` para filtrado de arrays

##### Estilos y Temas
- **Tailwind CSS**: Usado para todos los estilos, con plugin Prettier para ordenamiento de clases
- **Estilos globales**: En `src/styles/`

##### Commits y Contribución
- **Commits convencionales**: Aplicados vía commitlint
- **Nomenclatura de ramas**: `feature/<name>`, `fix/<issue>`
- **Pull requests**: Deben incluir descripción, enlace a issues y pasar todas las verificaciones

### 3.2 Patrones de Desarrollo Obligatorios

#### React Performance & Optimization Rules (Basado en project_rules.md)

**REQUISITOS CRÍTICOS**: Seguir estas reglas para evitar renders innecesarios y bucles infinitos en React.

##### 1. DEPENDENCIAS DE HOOKS
- `useEffect` / `useMemo` / `useCallback`: nunca omitir el array de dependencias
- No mentir a React: si una variable se usa dentro del efecto, debe estar en el array
- Regla de oro: si ESLint (`react-hooks/exhaustive-deps`) se queja, arréglalo, no lo silencies
- Objetos/funciones inline en deps ⇒ extraer a `useMemo`/`useCallback` primero

##### 2. ESTADO LOCAL VS GLOBAL
- Elevar estado solo cuando sea realmente necesario; evitar que el padre re-renderice todos los hijos por datos que solo necesita un hijo
- División de contexto: separar Contextos pesados (auth, theme, cart) en múltiples archivos para que los cambios no disparen re-renders globales
- Zustand / Jotai / Recoil > Context masivo cuando el árbol es grande

##### 3. MEMOIZACIÓN DE COMPONENTES
- `React.memo` para componentes hijos que reciben props primitivas o estabilizadas
- Siempre acompañar `React.memo` con `useCallback`/`useMemo` para funciones/objetos pasados como props
- Comparación personalizada con `areEqual` solo si la comparación superficial no es suficiente

##### 4. FUNCIONES Y OBJETOS INLINE
- Definir fuera del render cualquier función pura que no dependa de props/state
- `useCallback` para funciones pasadas a hijos memoizados o usadas en deps de hooks
- `useMemo` para objetos/arrays calculados desde props/state
- Evitar funciones flecha en JSX (`onClick={() => …}`) a menos que estén previamente memoizadas

##### 5. KEYS EN LISTAS
- Key única y estable (ID de BD, no índice del array)
- No usar `Math.random()` o `Date.now()` como key
- Re-ordenar listas ⇒ key debe continuar identificando el mismo elemento

##### 6. ASYNC / AWAIT EN useEffect
- No marcar `useEffect` como async; crear función async interna y llamarla inmediatamente
- `AbortController` / flag mounted para evitar setState en componente desmontado
- Limpiar timers, listeners y suscripciones en el return de useEffect

##### 7. CICLOS DE ACTUALIZACIÓN
- No setear el mismo estado con el valor que ya tiene (React no lo bloqueará)
- Evitar efectos que setean estado disparando el mismo efecto ⇒ revisar deps
- `useRef` para valores que no necesitan disparar render pero deben persistir

##### 8. RENDERIZADO CONDICIONAL TEMPRANO
- Return temprano en lugar de anidar JSX dentro de condicionales pesados
- Lazy load (`React.lazy` + `Suspense`) para rutas pesadas y modales

##### 9. PROPS DRILLING
- Componer children (patrón "slots") en lugar de pasar props 5 niveles abajo
- Context o estado externo solo cuando múltiples niveles necesitan los mismos datos

##### 10. HERRAMIENTAS DE DESARROLLO
- React DevTools Profiler → grabar interacción y ver qué componentes re-renderizan y por qué
- ¿Por qué se re-renderizó? (React DevTools → Settings → Highlight updates)
- `eslint-plugin-react-hooks` SIEMPRE habilitado

##### 11. ANTI-PATRONES SEVEROS
- ❌ `setState` en el cuerpo del componente (fuera de useEffect/evento)
- ❌ `useEffect` sin deps que solo "calcula" derivado ⇒ usar `useMemo`
- ❌ Efecto dependiendo de sí mismo (ej. dep `[value]` y dentro `setValue(value + 1)`)
- ❌ Mutar estado directamente (`push`, `splice`, etc.) ⇒ siempre nuevo objeto/array

##### 12. CHECKLIST RÁPIDO ANTES DE PUSH
- [ ] No `useEffect` sin array de dependencias
- [ ] No función/objeto inline pasado a hijo memoizado
- [ ] No `key={index}` o `key={Math.random()}`
- [ ] No `setState` dentro de render puro
- [ ] Todos los valores derivados en `useMemo`, no en `useEffect` o render
- [ ] `AbortController` o flag mounted en efectos con fetch
- [ ] React DevTools no muestra flashes de re-render en árbol estable

#### Container/Presentational Pattern
```typescript
// Container Component
const UserListContainer = () => {
  const { users, loading } = useUsers();
  return <UserListPresentation users={users} loading={loading} />;
};

// Presentational Component
interface UserListPresentationProps {
  users: User[];
  loading: boolean;
}
const UserListPresentation = ({ users, loading }: UserListPresentationProps) => {
  // Solo lógica de presentación
};
```

#### Custom Hooks Pattern
```typescript
const useAuth = () => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  
  // Lógica de autenticación
  
  return { user, loading, login, logout };
};
```

#### Compound Component Pattern
```typescript
const Modal = ({ children }: { children: React.ReactNode }) => {
  return <div className="modal">{children}</div>;
};

Modal.Header = ({ children }: { children: React.ReactNode }) => {
  return <div className="modal-header">{children}</div>;
};

Modal.Body = ({ children }: { children: React.ReactNode }) => {
  return <div className="modal-body">{children}</div>;
};
```

### 3.3 Gestión de Estado

#### Zustand Store Pattern
```typescript
interface AuthStore {
  user: User | null;
  isAuthenticated: boolean;
  login: (credentials: LoginCredentials) => Promise<void>;
  logout: () => void;
}

const useAuthStore = create<AuthStore>((set, get) => ({
  user: null,
  isAuthenticated: false,
  login: async (credentials) => {
    // Lógica de login
    set({ user: userData, isAuthenticated: true });
  },
  logout: () => {
    set({ user: null, isAuthenticated: false });
  },
}));
```

### 3.4 Componentes UI

#### Shadcn/ui Integration
- **OBLIGATORIO**: Usar `shadcn add` para nuevos componentes UI
- **Personalización**: Modificar solo a través de CSS variables en `globals.css`
- **Variantes**: Utilizar CVA para variantes de componentes

```typescript
import { cn } from "@/lib/utils";
import { cva, type VariantProps } from "class-variance-authority";

const buttonVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
);
```

### 3.5 Internacionalización

#### Estructura de Traducciones
```json
// messages/es.json
{
  "navigation": {
    "home": "Inicio",
    "about": "Acerca de",
    "contact": "Contacto"
  },
  "common": {
    "loading": "Cargando...",
    "error": "Error",
    "success": "Éxito"
  }
}
```

#### Uso en Componentes
```typescript
import { useTranslations } from 'next-intl';

const Navigation = () => {
  const t = useTranslations('navigation');
  
  return (
    <nav>
      <Link href="/">{t('home')}</Link>
      <Link href="/about">{t('about')}</Link>
    </nav>
  );
};
```

## 4. Sistema de Verificación de Calidad Obligatorio

**REQUISITO CRÍTICO**: Ninguna tarea puede considerarse completa sin pasar TODAS las verificaciones de calidad. Este es un sistema de verificación OBLIGATORIO que debe ejecutarse antes de marcar cualquier tarea como finalizada.

### 4.1 Verificaciones de Calidad Requeridas (Todas Deben Pasar)

#### 1. Verificación de Ortografía
- **Comando**: `pnpm run check:spell`
- **Criterio**: Debe retornar 0 errores y 0 advertencias
- **Acción**: Corregir todos los errores tipográficos y ortográficos antes de proceder

#### 2. Compilación de Build
- **Comando**: `pnpm run build`
- **Criterio**: Debe completarse con código de salida 0
- **Acción**: No se permiten errores o advertencias de compilación TypeScript

#### 3. Linting y Formateo de Código
- **Comandos**: 
  - `pnpm run lint`
  - `pnpm run check:format`
- **Criterio**: Debe retornar 0 errores ESLint Y 0 advertencias
- **Acción**: Debe pasar las verificaciones de formateo Prettier sin problemas

#### 4. Verificación de Tipos TypeScript
- **Incluido en**: Proceso de build
- **Criterio**: No se permiten errores o advertencias de tipos
- **Acción**: Mantener tipado estricto con tolerancia cero para advertencias

#### 5. Revisión de Calidad de Código
- Eliminar comentarios innecesarios
- Asegurar documentación JSDoc adecuada
- Verificar que no hay código muerto o imports no utilizados

### 4.2 Procedimientos de Detección Automatizada

```bash
# Secuencia completa de verificación de calidad (todas deben pasar)
pnpm run check:spell     # Verificación ortográfica
pnpm run lint           # Verificación ESLint
pnpm run check:format   # Verificación Prettier
pnpm run build          # Verificación TypeScript y build
```

### 4.3 Protocolo de Notificación y Corrección de Errores

1. **Detección**: Ejecutar todas las verificaciones de calidad en secuencia
2. **Notificación**: Cualquier verificación fallida debe reportarse con:
   - Detalles específicos del error
   - Ubicaciones de archivos
   - Correcciones sugeridas
3. **Corrección**: TODOS los errores deben corregirse antes de completar la tarea
4. **Re-verificación**: Re-ejecutar todas las verificaciones después de las correcciones
5. **Finalización**: Solo proceder cuando TODAS las verificaciones pasen con 0 errores/advertencias

### 4.4 Reglas de Aplicación

- **Tolerancia Cero**: No hay excepciones para fallas en verificaciones de calidad (errores O advertencias)
- **Cobertura Completa**: Todos los archivos modificados deben pasar las verificaciones de calidad con cero errores y cero advertencias
- **Documentación**: Todas las correcciones deben documentarse en mensajes de commit
- **Verificación**: La verificación final debe realizarse antes del cierre de la tarea
- **Política de Advertencias**: Las advertencias se tratan como fallas y deben resolverse antes de la finalización

### 4.5 Logging Centralizado

#### Sistema de Logger Obligatorio
- **Ubicación**: `src/lib/utils/logger.ts`
- **Prohibido**: Uso de métodos `console` directos
- **Imports requeridos**: `logInfo`, `logWarn`, `logError`, `logDebug`
- **Características**: 
  - Logging basado en módulos
  - Niveles configurables
  - Almacenamiento persistente

```typescript
// Ejemplo de uso correcto
import { logInfo, logError } from '@/lib/utils/logger';

// ❌ Incorrecto
console.log('Debug info');

// ✅ Correcto
logInfo('Debug info', { module: 'UserAuth' });
```

### 4.6 Herramientas de Desarrollo IDE

#### Extensiones VS Code Recomendadas
- **ESLint**: Análisis en tiempo real
- **Prettier**: Formateo automático
- **SonarLint**: Feedback de calidad de código en tiempo real
- **Error Lens**: Visualización de errores inline
- **Tailwind CSS IntelliSense**: Autocompletado de clases
- **CodeMetrics**: Métricas de complejidad
- **Import Cost**: Análisis de tamaño de imports
- **Pretty TypeScript Errors**: Errores TypeScript legibles

### 4.7 Análisis Estático de Código

#### ESLint - Reglas Obligatorias
```javascript
{
  "rules": {
    "@typescript-eslint/no-explicit-any": "error",
    "@typescript-eslint/no-unused-vars": "error",
    "@typescript-eslint/explicit-function-return-type": "warn",
    "react-hooks/rules-of-hooks": "error",
    "react-hooks/exhaustive-deps": "error", // Cambiado de "warn" a "error"
    "no-console": "error", // Prohibir console.log
    "no-duplicate-imports": "error"
  }
}
```

#### Prettier - Configuración Estándar
```json
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 80,
  "tabWidth": 2,
  "useTabs": false
}
```

### 4.8 Git Hooks y Automatización

#### Husky + lint-staged
```json
{
  "husky": {
    "hooks": {
      "pre-commit": "lint-staged",
      "pre-push": "pnpm run type-check && pnpm run test && pnpm run check:spell",
      "commit-msg": "commitlint -E HUSKY_GIT_PARAMS"
    }
  },
  "lint-staged": {
    "*.{ts,tsx,js,jsx}": [
      "eslint --fix",
      "prettier --write"
    ],
    "*.{md,json}": [
      "prettier --write"
    ]
  }
}
```

### 4.9 Tests y Automatización

#### Playwright - Tests E2E
- **Comando**: `pnpm run test:app`
- **Configuración**: `playwright.config.ts`
- **Cobertura mínima**: 80% en flujos críticos

#### Tests Unitarios
- **Ubicación**: Junto a componentes con sufijo `.test.tsx`
- **Cobertura mínima**: 85% para funciones críticas
- **API Falsa**: `pnpm run fake:api` para desarrollo local

#### Scripts de Calidad
```json
{
  "scripts": {
    "check:isReady": "pnpm run check:spell && pnpm run lint && pnpm run check:format && pnpm run build && pnpm run test",
    "format:fix": "prettier --write .",
    "check:format": "prettier --check .",
    "check:spell": "cspell \"**/*.{ts,tsx,md,json}\"",
    "lint": "eslint . --fix"
  }
}
```

## 5. Referencias y Mejores Prácticas

### 5.1 Recursos de Componentes Compatibles

#### Bibliotecas Aprobadas
- **Shadcn/ui**: https://ui.shadcn.com/
- **Shadcn Blocks**: https://ui.shadcn.com/blocks
- **Aceternity UI**: https://ui.aceternity.com/
- **Radix UI**: https://www.radix-ui.com/

#### Context7 MCP - Soluciones Existentes
Antes de implementar nuevas funcionalidades, verificar:
1. **Requisitos de seguridad** cumplidos
2. **Mantenibilidad a largo plazo** garantizada
3. **Compatibilidad** con el stack tecnológico
4. **Documentación** adecuada disponible

### 5.2 Patrones de Rendering

#### Static Site Generation (SSG)
```typescript
// Para páginas estáticas
export async function generateStaticParams() {
  return [
    { locale: 'en' },
    { locale: 'es' },
    { locale: 'da' }
  ];
}
```

#### Server-Side Rendering (SSR)
```typescript
// Para páginas dinámicas con datos del servidor
export default async function Page({ params }: { params: { id: string } }) {
  const data = await fetchData(params.id);
  return <PageComponent data={data} />;
}
```

### 5.3 Optimización de Performance

#### Image Optimization
```typescript
import Image from 'next/image';

const OptimizedImage = () => (
  <Image
    src="/hero-image.jpg"
    alt="Hero image"
    width={800}
    height={600}
    priority
    placeholder="blur"
    blurDataURL="data:image/jpeg;base64,..."
  />
);
```

#### Bundle Analysis
```bash
# Análisis obligatorio antes de producción
pnpm build
pnpm run analyze
```

### 5.4 Configuración de Producción

#### Variables de Entorno
```bash
# .env.local
NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=pk_test_...
CLERK_SECRET_KEY=sk_test_...
NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
```

#### Next.js Configuration
```typescript
// next.config.ts
const nextConfig = {
  experimental: {
    turbopack: true,
  },
  images: {
    domains: ['example.com'],
    formats: ['image/webp', 'image/avif'],
  },
  i18n: {
    locales: ['en', 'es', 'da'],
    defaultLocale: 'en',
  },
};
```

## 6. Documentación Obligatoria

### 6.1 JSDoc - Estándar Requerido

```typescript
/**
 * Autentica un usuario con las credenciales proporcionadas
 * @param credentials - Objeto con email y password del usuario
 * @returns Promise que resuelve con los datos del usuario autenticado
 * @throws {AuthError} Cuando las credenciales son inválidas
 * @example
 * ```typescript
 * const user = await authenticateUser({
 *   email: 'user@example.com',
 *   password: 'securePassword123'
 * });
 * ```
 */
async function authenticateUser(credentials: LoginCredentials): Promise<User> {
  // Implementación
}
```

### 6.2 VitePress - Estructura de Documentación

```markdown
# Documentación del Proyecto

## Componentes
- [Button](./components/button.md)
- [Modal](./components/modal.md)
- [DataTable](./components/data-table.md)

## Hooks
- [useAuth](./hooks/use-auth.md)
- [useLocalStorage](./hooks/use-local-storage.md)

## Patrones
- [Container/Presentational](./patterns/container-presentational.md)
- [Custom Hooks](./patterns/custom-hooks.md)
```

## 7. Checklist de Implementación Final

### Pre-desarrollo
- [ ] Configuración inicial del proyecto con pnpm
- [ ] Instalación de dependencias según stack tecnológico
- [ ] Configuración de herramientas de desarrollo (ESLint, Prettier, Husky)
- [ ] Setup de Shadcn/ui con `npx shadcn@latest init`
- [ ] Configuración de spell checking con cspell
- [ ] Setup de SonarLint en IDE para feedback en tiempo real

### Desarrollo
- [ ] Implementación de autenticación con Clerk.js
- [ ] Configuración de internacionalización con next-intl
- [ ] Setup de Zustand para estado global
- [ ] Integración de TanStack Query para gestión de datos
- [ ] Implementación de tema claro/oscuro
- [ ] Creación de componentes base con Shadcn/ui
- [ ] Implementación de sistema de logging centralizado
- [ ] Configuración de manejo de errores con ErrorAlertsList

### Calidad (Sistema de Verificación Obligatorio)
- [ ] **Verificación ortográfica**: `pnpm run check:spell` (0 errores/advertencias)
- [ ] **Compilación de build**: `pnpm run build` (código de salida 0)
- [ ] **Linting y formateo**: `pnpm run lint` && `pnpm run check:format` (0 errores/advertencias)
- [ ] **Verificación de tipos**: TypeScript strict mode sin errores
- [ ] **Tests unitarios**: Cobertura mínima del 85% para funciones críticas
- [ ] **Tests E2E con Playwright**: Cobertura mínima del 80% en flujos críticos
- [ ] **Documentación JSDoc**: Completa en todas las funciones públicas
- [ ] **Revisión de accesibilidad**: WCAG 2.1 AA compliance
- [ ] **Checklist de React Performance**: Todos los puntos verificados
- [ ] **Git hooks funcionando**: Pre-commit y pre-push ejecutándose correctamente

### Scripts de Verificación Automatizada
```bash
# Ejecutar secuencia completa de verificación de calidad
pnpm run check:spell     # Verificación ortográfica
pnpm run lint           # Verificación ESLint
pnpm run check:format   # Verificación Prettier
pnpm run build          # Verificación TypeScript y build
pnpm run test           # Tests unitarios
pnpm run test:app       # Tests E2E con Playwright

# Script integrado de verificación pre-deploy
pnpm run check:isReady  # Ejecuta todas las verificaciones anteriores
```

### Producción
- [ ] Optimización de bundle size con análisis
- [ ] Configuración de variables de entorno
- [ ] Setup de CI/CD pipeline con verificaciones de calidad
- [ ] Documentación VitePress generada
- [ ] Performance audit (Lighthouse > 90)
- [ ] Verificación final con tolerancia cero para errores/advertencias

### Verificación de Cumplimiento de Reglas
- [ ] **Inglés obligatorio**: Todo código, comentarios, documentación y commits en inglés
- [ ] **Tipado estricto**: Prohibición absoluta del tipo 'any'
- [ ] **Logging centralizado**: No uso de métodos console directos
- [ ] **Arquitectura basada en características**: Organización por feature, no por tipo
- [ ] **Componentes type-safe**: Todos los componentes con interfaces TypeScript
- [ ] **Memoización adecuada**: React.memo, useCallback, useMemo implementados correctamente
- [ ] **Gestión de estado**: Zustand para estado global, hooks personalizados para lógica
- [ ] **Manejo de errores**: ErrorAlertsList con botones accionables
- [ ] **Commits convencionales**: Formato commitlint aplicado

---

**Nota Importante**: Este documento es la referencia obligatoria para todas las implementaciones de Trae AI. Cualquier desviación de estos estándares debe ser justificada y documentada explícitamente.

**Versión**: 2.0  
**Última actualización**: Enero 2025  
**Mantenido por**: Trae AI Development Team
